{
  "name": "curl",
  "version": "0.8.9",
  "description": "curl.js is small, fast, extensible module loader that handles AMD, CommonJS Modules/1.1, CSS, HTML/text, and legacy scripts.",
  "keywords": [
    "curl",
    "cujo",
    "amd",
    "loader",
    "module",
    "commonjs",
    "css",
    "html",
    "json"
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "http://www.opensource.org/licenses/mit-license.php"
    }
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/cujojs/curl"
  },
  "bugs": {
    "url": "https://github.com/cujojs/curl/issues"
  },
  "maintainers": [
    {
      "name": "John Hann",
      "url": "http://unscriptable.com"
    }
  ],
  "contributors": [
    {
      "name": "John Hann",
      "url": "http://unscriptable.com"
    },
    {
      "name": "Brian Cavalier",
      "url": "http://hovercraftstudios.com"
    }
  ],
  "main": "./src/curl",
  "directories": {
    "test": "test"
  },
  "volo": {
    "type": "directory"
  },
  "readme": "curl (cujoJS resource loader)\n=====================\n\nWhat is curl.js?\n================\n\ncurl.js is a small and very fast AMD-compliant asynchronous loader.\nSize: ~4KB (gzipped) using Google's Closure Compiler.\n\nIf you'd like to use curl.js for non-AMD modules (ordinary javascript files),\nyou'll want to use the legacy loader.\n\ncurl.js, like all async loaders, cannot circumvent browsers' security\nrestrictions when using the `file:` protocol.  Therefore, you must use\ncurl from a page served from a web server (i.e. using `http:` or `https:`).\nTrying to run curl.js from a page loaded from your local file system\nwill not work correctly in all browsers.\n\nWhat the heck is \"cujoJS\"?  cujoJS is the JavaScript Architectural Toolkit.\nMore info: [cujojs.com](http://cujojs.com)\n\nWhat is \"cram\"? cram (cujoJS resource assembler) is the build tool companion to\ncurl.js.  You use cram to compile all of your modules into a small number of\njavascript files which are loaded much faster into the browsers.\n\n----------------------------------------\n\nFeatures at a glance:\n=====================\n\n* Loads AMD-formatted javascript modules in parallel\n* Loads CommonJS/node modules (v1.1 when wrapped in a `define()`)\n* Loads CommonJS/node modules (unwrapped when using the cjsm11 loader)\n* Loads non-AMD javascript files in parallel, too.\n* Loads CSS files and text files in parallel\n* Waits for dependencies (js, css, text, etc) before executing javascript\n* Waits for domReady, if desired\n* Allows for virtually limitless combinations of files and dependencies\n* Tested with Safari 5+, IE6+, and recent Chrome, FF, Opera\n\nMore detailed information below and on the\n[wiki](https://github.com/cujojs/curl/wiki).\n\n----------------------------------------\n\nHow to get support\n===============\n\n1. Go to the issues section of the curl repo\n   (https://github.com/cujojs/curl/issues) and search for an answer to your\n   question or problem.\n2. If no answer exists, file a new ticket!  Somebody will typically respond\n   within a few hours.\n\nIt's that easy.\n\nGot more in-depth questions?  Browse the\n[cujoJS discussion group](https://groups.google.com/d/forum/cujojs) or\ncome chat with us on freenode @ #cujojs.\n\nSee the [wiki](https://github.com/cujojs/curl/wiki) for information about using\ncurl.js with jQuery, dojo, or underscore.\n\n----------------------------------------\n\nWhat's New?\n=======\n\n* 0.8.9\n\t* Protect more API functions in plugins and loaders from closure compiler's\n\taggressive obfuscation.\n\t* Switch to newer //# sourceURL syntax.\n\t* Stop doubling the \".js\" on the sourceURL.\n\t* Ensure that `define` is undefined when wrapping cjs/node modules.\n* 0.8.8\n\t* Stop double-appending .css extension in css! plugin.\n\t(thanks @stanislawosinski!)\n* 0.8.7\n\t* Fix botched release wherein some dummy forgot to `bin/make-all.sh`.\n* 0.8.6\n\t* Cram plugins: hide legacy plugin's `define` from cram parser.\n* 0.8.5\n\t* Cram plugins: plugins are now responsible for resolving url/filepath.\n\t* Cram plugins: legacy loader no longer fails to add a .js extension\n\t  when there are dots in the file name.\n* 0.8.4\n\t* data-curl-run now only supports scripts, not modules, and is\n\t  documented in the bootstrapping section of the wiki.\n\t  There are now fewer conflicts when defining a\n\t  main module in the curl config, as a result.\n* 0.8.3\n\t* Export legacy-loaded modules with normal AMD/CommonJS module ids\n\t  (thanks @mmacaula!)\n\t* Build curl/debug into curl/dist/debug/curl.js correctly.\n* 0.8.2\n\t* Run compile.sh from anywhere (thanks @webpro!)\n\t* Restore quotes to cram text plugin output (thanks @gehan!)\n\t* Correctly bake-in the locale module in the kitchen-sink dist build.\n* 0.8.1\n\t* Adds a build-time (cram) plugin for the new legacy loader.\n* 0.8.0\n\t* Adds new curl/loader/legacy module loader that provides similar\n\t  functionality to RequireJS's \"shim config\".\n\t* Adds dontAddFileExt config option functionality to js! plugin and\n\t  curl/loader/legacy module loader.\n\t* Fixes configuration context mixups. Modules will get their package's\n\t  config unless they are loaded explicitly via a plugin and that\n\t  plugin has a custom configuration.\n\t* Paths can now be objects like packages and can have all of the same\n\t  properties, except `main`, i.e. `location` (or `path`), `config`, `name`.\n\t* Fixes an issue in node on windows wherein C: was seen as a web protocol.\n\t* Updates READMEs in the plugin and loader folders.\n\t* Drops dojo 1.6 compatibility in the \"kitchen sink\" distribution.\n\t* Adds new dojo 1.8 distribution.\n\n----------------------------------------\n\nAPI at a glance\n===============\n\nAt it's core, curl.js provides an AMD environment:\n\n```javascript\ndefine(['dep1', 'dep2', 'dep3' /* etc */], factory);\ndefine(['dep1', 'dep2', 'dep3' /* etc */], module);\ndefine(module);\ndefine(name, ['dep1', 'dep2', 'dep3' /* etc */], factory);\ndefine(name, ['dep1', 'dep2', 'dep3' /* etc */], module);\ndefine(name, module);\n```\n\nThese all define a module per the AMD specification.\n\n* ['dep1', 'dep2', 'dep3']: Module names or plugin-prefixed resource files.\nDependencies may be named 'require', 'exports', or 'module' and will behave\nas defined in the CommonJS Modules 1.1 proposal.\n* factory: Function called to define the module.  Each dependency is\n  passed as a parameter to the factory.\n* module: Any javascript object, function, constructor, or primitive\n* name: String used to name a module. This is not necessary nor is it\n  recommended.  \"Named modules\" are typically only created by build tools\n  and AMD bundlers.\n\n----------------------------------------\n\n```javascript\ndefine(function (require, exports, module) {\n\tvar dep1 = require('app/foo');\n\texports.foo2 = function () { return foo() + 2; };\n});\n```\n\nDefines a module using the AMD-wrapped-CommonJS format.  If a factory function\nhas parameters, but the dependency list is missing, this format is assumed.\nThe `exports` and `module` parameters are optional, but when specified, must\nbe in this exact order.\n\n----------------------------------------\n\n```javascript\ndefine(function (require) {\n\tvar dep1 = require('app/foo');\n\treturn function () { return foo() + 2; };\n});\n```\n\nAnother variation on AMD-wrapped-CommonJS that uses `require()` in the\ntidy CommonJS manner, but returns the exports as per typical AMD.\n\n----------------------------------------\n\n```javascript\ndefine(['require', 'exports', 'module'], function (require, exports, module) {\n\tvar dep1 = require('app/foo');\n\texports.foo2 = function () { return foo() + 2; };\n});\n```\n\nAnother way to gain access to the CommonJS-like variables, `require`,\n`exports`, `module`.  When specified in the dependency list, these\n\"pseudo-modules\" are provided as arguments to the factory function.\n\n----------------------------------------\n\n```javascript\nvar dep1 = require('app/foo');\nexports.foo2 = function () { return foo() + 2; };\n```\n\ncurl.js also supports *unwrapped* CommonJS modules (and node.js modules)\nvia the cjsm11 module loader. To use this module loader for a package, say\nBackbone, you would provide it to a package config, like this:\n\n```javascript\ncurl.config({\n\tpackages: [\n\t\t{\n\t\t\tname: 'backbone',\n\t\t\tlocation: 'bower_components/backbone'\n\t\t\tmain: 'backbone.min.js',\n\t\t\tconfig: { moduleLoader: 'curl/loader/cjsm11' } /* <-- hey! */\n\t\t}\n\t]\n});\n```\n\nRead the notes in the src/curl/loader folder and the cjsm11.js file for\nmore information about loading CommonJS and node.js modules.\n\n-----\n\ncurl.js's global API is for bootstrapping an app.  You would typically only use\nthis API *once* in your application to load the main module of your application.\n\nFor a complete description, check out the [wiki](https://github.com/cujojs/curl/wiki).\n\n```javascript\ncurl(['main', 'other', 'another' /* etc */], callback, errorback);\n```\n\nLoads a module named \"main\" along with two other modules and the executes\ncallback, handing it the exported values of the modules as parameters.\n\n* ['main', 'other', 'another']: Module names or plugin-prefixed resource files.\n* callback: Function to receive modules or resources. This is where you'd\n  typically start up your app. Optional.\n* errorback: Function to receive an exception parameter when loading fails.\n   Optional.\n\n---------\n\n```javascript\ncurl(['main', 'other', 'another' /* etc */])\n\t.then(callback, errorback);\n```\n\nPromises-based API for executing callbacks.\n\n* ['main', 'other', 'another']: Module names or plugin-prefixed resource files.\n* callback: Function to receive modules or resources. Optional.\n* errorback: Function to call if an exception occurred while loading. Optional.\n* For full CommonJS Promises/A+ compliance, use [when.js](https://github.com/cujojs/when)\n    * `when(curl(['dep1'])).then(callback);`\n\n---------\n\n```javascript\ncurl(config, ['main' /* etc */], callback, errorback);\n```\nSpecify configuration options, load dependencies, and execute callback.\n\n* config: Object containing curl configuration options (paths, etc.)\n* ['main']: Module name(s).\n* callback: Function to receive modules or resources. Optional.\n* errorback: Function to call if an exception occurred while loading. Optional.\n\n---------\n\n```javascript\ncurl(['main', 'domReady!' /* etc */]).then(\n\tcallback,\n\terrorback\n);\n```\n\n```javascript\ncurl(['main', 'domReady!' /* etc */], function (main) {\n\t// do some bootstrapping here\n});\n```\n\nExecutes the callback when the dom is ready for manipulation AND\nall dependencies have loaded.\n\n---------\n\n```javascript\ncurl(['domReady!', 'js!nonAMD.js!order', 'js!another.js!order']), function () {\n\t/* do something cool here */\n});\n```\n\nExecutes the function when the non-AMD javascript files are loaded and\nthe dom is ready. The another.js file will wait for the nonAMD.js file\nbefore executing.\n\nNote: Please use curl.js's new legacy loader for much more flexible and\nsensible loading of non-AMD scripts.  Please read the docs in the\nsrc/curl/loader folder for more information.\n\nNote: if a file supports AMD or CommonJS module formats, you *can not* use the\njs! plugin on that file.\n\n---------\n\n```javascript\ncurl(['js!nonAMD.js'])\n\t.next(['dep1', 'dep2', 'dep3'], function (dep1, dep2, dep3) {\n\t\t// do something before the dom is ready\n\t})\n\t.next(['domReady!'])\n\t.then(\n\t\tfunction () {\n\t\t\t// do something after the dom is ready\n\t\t},\n\t\tfunction (ex) {\n\t\t\t// show an error to the user\n\t\t}\n\t);\n```\n\nExecutes callbacks in stages using `.next(deps, callback)`.\n\nNote: `.next()` does not load resources in parallel.  Therefore, it is a\nlast resort when other options do not satisfy your use case.  You should\nuse the `preloads` config option and/or the legacy loader\nwhenever possible.\n\n---------\n\n```javascript\ncurl = {\n\tbaseUrl: '/path/to/my/js',\n\tpluginPath: 'for/some/reason/plugins/r/here',\n\tpaths: {\n\t\tcurl: 'curl/src/curl',\n\t\tcssx: 'cssx/src/cssx',\n\t\tmy: '../../my-lib/'\n\t},\n\tapiName: 'someOtherName'\n};\n```\n\nIf called before the `<script>` that loads curl.js, a global `curl` var will\nconfigure curl.js when it loads.  All of the configuration parameters are\noptional. curl.js tries to do something sensible in their absence. :)\n\nSome common configuration options:\n\n* baseUrl: the root folder to find all modules, default is the document's folder\n* paths: a mapping of module paths to relative paths (from baseUrl)\n* pluginPath: the place to find plugins when they are specified without a path\n(e.g. \"css!myCssFile\" vs. \"cssx/css!myCssFile\") and there is no paths\nmapping that applies.\n* apiName: an alternate name to `curl` and `require` for curl.js's global\n  variable\n* apiContext: an object, rather than `window`, to place curl on when using\n  `apiName`\n\nA more complete list can be found on the\n[wiki](https://github.com/cujojs/curl/wiki/Configuring-curl.js).\n\n----------------------------------------\n\nVery Simple Example\n===================\n\n```html\n<script>\n\n\t// configure curl\n\tcurl = {\n\t\tpaths: {\n\t\t\tcssx: 'cssx/src/cssx/',\n\t\t\tstuff: 'my/stuff/'\n\t\t}\n\t};\n\n</script>\n<script src=\"../js/curl.js\" type=\"text/javascript\"></script>\n<script type=\"text/javascript\">\n\n\tcurl(\n\t\t// fetch all of these resources (\"dependencies\")\n\t\t[\n\t\t\t'stuff/three', // an AMD module\n\t\t\t'cssx/css!stuff/base', // a css file\n\t\t\t'i18n!stuff/nls/strings', // a translation file\n\t\t\t'text!stuff/template.html', // an html template\n\t\t\t'domReady!'\n\t\t]\n\t)\n\t// when they are loaded\n\t.then(\n\t\t// execute this callback, passing all dependencies as params\n\t\tfunction (three, link, strings, template) {\n\t\t\tvar body = document.body;\n\t\t\tif (body) {\n\t\t\t\tbody.appendChild(document.createTextNode('three == ' + three.toString() + ' '));\n\t\t\t\tbody.appendChild(document.createElement('br'));\n\t\t\t\tbody.appendChild(document.createTextNode(strings.hello));\n\t\t\t\tbody.appendChild(document.createElement('div')).innerHTML = template;\n\t\t\t}\n\t\t},\n\t\t// execute this callback if there was a problem\n\t\tfunction (ex) {\n\t\t\tvar msg = 'OH SNAP: ' + ex.message;\n\t\t\talert(msg);\n\t\t}\n\t);\n\n</script>\n```\n\nThe file structure for this example would look as follows:\n\n\tjs/\n\t\tcurl/\n\t\t\tplugin/\n\t\t\t\ti18n.js\n\t\t\t\ttext.js\n\t\t\tdomReady.js\n\t\tcssx/\n\t\t\tsrc/\n\t\t\t\tcssx/\n\t\t\t\t\tcss.js\n\t\tmy/\n\t\t\tstuff/\n\t\t\t\tnls/\n\t\t\t\t\tstrings.js\n\t\t\t\tbase.css\n\t\t\t\ttemplate.html\n\t\t\t\tthree.js\n\t\tcurl.js\n\n----------------------------------------\n\nWhat is an asynchronous loader?\n===============================\n\nWeb apps, especially large ones, require many modules and resources. Most of\nthese modules and resources need to be loaded at page load, but some may be\nloaded later, either in the background or \"just in time\". They also need to be\nloaded as quickly as possible.\n\nThe traditional way to load javascript modules is via a `<SCRIPT>` element in\nan HTML page. Similarly, CSS files are loaded via a `<LINK>` element, and\ntext resources are either loaded in the page or via XHR calls.\n\nThe problem with `<SCRIPT>` and `<LINK>` elements is that a browser must execute\nthem sequentially since it has no idea if one may depend on another. It just\nassumes the developer has placed them in the correct order and that there are\ndependencies. (The term \"synchronous loading\" is used to describe this process\nsince the elements are executed in a single timeline.)\n\nIf there are no dependencies between two files, loading them sequentially is\na waste of time. These files could be loaded and executed in parallel (i.e\nat the same time).\n\nAn asynchronous loader does just that: it loads javascript files (and\nother types of files) in parallel whenever possible.\n\ncurl.js has lots of company. Other async loaders include LABjs, Steal.js,\nyepnope.js, $script.js, the Backdraft loader (bdLoad), and RequireJS.\n\n[(a more complete list)](https://spreadsheets.google.com/ccc?key=0Aqln2akPWiMIdERkY3J2OXdOUVJDTkNSQ2ZsV3hoWVE&hl=en#gid=2)\n\n----------------------------------------\n\nWhat is AMD?\n============\n\nAsynchronous Module Definition is a *de facto* standard for\njavascript modules that can be loaded by asynchronous loaders. It defines\na simple API that developers can use to write their javascript modules so\nthat they may be loaded by any AMD-compliant loader.\n\n[AMD Spec](https://github.com/amdjs/amdjs-api/wiki/AMD)\n\nThe AMD proposal follows some parts of the\n[CommonJS Modules](http://wiki.commonjs.org/wiki/Modules/1.1) proposal.\nBecause of the way browsers load and\nevaluate scripts, AMD can't follow it completely without causing significant\nprocessing overhead.  Instead, AMD allows us to place a lightweight wrapper\naround javascript modules to help work around the shortcomings.\n\nUltimately, both proposals (AMD and Modules 1.1) are in preparation for an\nofficial [javascript modules](http://wiki.ecmascript.org/doku.php?id=harmony:modules)\nspecification and eventual implementation in browsers.\n\nIf you don't want to wait for official javascript modules, then don't.\nThe future is now.  AMD works now -- and it's awesome.\n\nAMD's API focuses on one globally-available function: `define()` and some\nCommonJS-inspired variables, `require()`, `exports`, and `module`.\n`require()` specifies a list of dependent modules or resources that must be\nloaded before running a set of code. This code resides in a callback function\nthat is executed asynchronously, i.e. it runs later, not in the current\n\"thread\".  Specifically, it executes when all of the dependencies are loaded\nand ready.\n\nThe proposal does not mandate that `require()` be specified globally.  In fact,\nat a global level, the concerns of a loader are about application bootstrapping\nand not about finding dependencies. To keep the confusion about these two\nconcepts to a minimum, curl.js uses `curl()` for the public API.  You may rename\nthis API back to `require()` by supplying the `apiName` config param\n(`apiName: \"require\"`), but this is not recommended.\n\nIt's more important that the `define()` method be consistent.  This is the\nmethod that tells the loader what modules have been loaded by a script.\n`define()`  also specifies a list of dependencies and a callback function that\ndefines and/or creates the resource when the dependencies are ready.\nOptionally, `define()` also takes a name parameter, but this is mainly for build\ntools and optimizers.\n\nInside the `define()`, the `require()` method acts like other AMD loaders.\n\nAMD's API also helps code reuse by providing compatibility with CommonJS\n(server) modules. AMD-compliant loaders support the same `require()` syntax and\nargument signatures as server-side javascript (ssjs) modules.\n\nThe beauty of AMD loaders is their ability to remove the drudgery of manually\nmanaging dependencies.  Since all dependencies are listed within the\nmodules, the loader will ensure that everything is loaded into the browser --\nand in the right order.\n\n----------------------------------------\n\nCan curl.js work with non-AMD and non-CommonJS javascript files?\n===============================================\n\nYes, but why would you?  Once you start using AMD, you'll never go back! :)\n\nYou may use non-AMD javascript files by using the legacy loader\nlike this:\n\n```javascript\ncurl.config({\n\tpaths: {\n\t\tplainOldJsFile1: {\n\t\t\tlocation: 'js/plainOldJsFile1.js',\n\t\t\tconfig: { loader: 'curl/loader/legacy', exports: 'aGlobal' }\n\t\t},\n\t\tanotherPlainOldJsFile: {\n\t\t\tlocation: 'js/anotherPlainOldJsFile.js',\n\t\t\tconfig: { \n\t\t\t\tloader: 'curl/loader/legacy', \n\t\t\t\texports: 'anotherGlobal',\n\t\t\t\trequires: [ 'plainOldJsFile1' ]\n\t\t\t}\n\t\t}\n\t}\n});\ncurl(['anotherPlainOldJsFile']).then(\n\tfunction (anotherGlobal) {\n\t\t/* do something with your plain, boring javascript files */\n\t},\n\tfunction () {\n\t\t/* do something if any fail to load */\n\t}\n);\n```\n\nPlease read the docs in the src/curl/loader folder for more information.\n\n----------------------------------------\n\nCan curl.js load non-javascript files via plugins?\n=======================\n\nYes, curl.js follows the CommonJS Loader Plugin specification, so you can use\nany compatible plugin. The following plugins are included:\n\njs! -- loads non-AMD javascript files. more info on the [wiki](https://github.com/cujojs/curl/wiki/js)\n\ntext! -- loads text files\n\nlink! -- loads css files via a link element (simple, fast)\n\ncss! -- loads css files (lots of options)\n\ndomReady! -- resolves when the dom is ready for manipulation\n\nasync! -- resolves when a module signals it's ready\n\ni18n! -- loads text strings and other locale-specific constants\n\nSome plugin docs are on the [wiki](https://github.com/cujojs/curl/wiki/Plugins).\n\nMore documentation is available inside the source of these plugins!\n\n----------------------------------------\n\nHow are modules loaded?\n=======================\n\ncurl.js uses `<script>` element injection rather than XHR/eval for AMD modules.\nThis allows curl.js to load cross-domain scripts as well as local scripts.\nCommonJS modules use XHR/eval so must be wrapped for \"transport\" if not\non the same domain.  Typically, you will bundle your modules before using them\nin production, anyways.  Most bundlers will wrap CommonJS modules in AMD.\n\nTo find scripts and other resources, curl.js uses module names.  A module name\nlooks just like a file path, but typically without the file extension.  If a\nmodule requires a plugin in order to load correctly, it will have a prefix\ndelimited by a \"!\" and will also often have a file extension when a plugin\nmay load different types of files.\n\nSome examples of module names:\n\n* dojo/store/JsonRest\n* my/lib/string/format\n* js!my/lib/js/plain-old-js.js\n* css!my/styles/reset.css\n* http://some-cdn/uber/module\n\nBy default, curl.js will look in the same folder as the current document's\nlocation. For instance, if your web page is located at\n`http://my-domain/apps/myApp.html`, curl.js will look for the JsonRest module\nat `http://my-domain/apps/dojo/store/JsonRest.js`.\n\nYou can tell curl.js to find modules in other locations by specifying a baseUrl\nor individual packages for each of your libraries.  For example, if you specify\na baseUrl of `/resources/` and the following paths:\n\n```javascript\npackages: [\n\t{ name: \"dojo\", location: \"third-party/dojo\" },\n\t{ name: \"css\", location: \"third-party/cssmojo/css\" },\n\t{ name: \"my\", location: \"my-cool-app-v1.3\" },\n\t{ name: \"my/lib/js\", location: \"old-js-libs\" }\n]\n```\n\nThen the modules listed above will be sought in the following locations:\n\n* /resources/third-party/dojo/store/JsonRest.js\n* /resources/my-cool-app-v1.3/lib/string/format.js\n* /resources/old-js-libs/plain-old-js.js\n* /resources/my-cool-app-v1.3/styles/reset.css\n* http://some-cdn/uber/module.js\n\nNote: you will need to create a path to curl.js's plugins and other modules if\nthe curl folder isn't directly under the same folder as your web page. curl.js\nuses the same mechanism to find its own modules.\n\n----------------------------------------\n\nWhat are AMD plugins?\n=====================\n\nAMD supports the notion of plugins. Plugins are AMD modules that can be used to\nload javascript modules -- or other types of resources. curl comes with several\nplugins already, including a text plugin (for templates or other text\nresources), two different css plugins, a dom-ready plugin, and several others.\n\nPlugins are designated by a prefix on the name of the module or resource to be\nloaded. They are delineated by a ! symbol. The following example shows the use\nof some plugins:\n\n```javascript\ndefine(\n\t[\n\t\t'text!myTemplate.html',\n\t\t'css!myCssFile'\n\t],\n\tfunction (templateString, cssLinkNode) {\n\t\t// do something with the template and css here\n\t}\n);\n```\n\nSince plugins are just AMD modules, they would typically be referenced using\ntheir fully-pathed names. curl provides a pluginPath configuration option that\nallows you to specify the folder where [most of] your plugins reside so you\ndon't have to specify their full paths.  This also helps with compatibility\nwith other AMD loaders.\n\nIf one or more of your plugins does not reside in the folder specified by the\npluginPath config option, you can use its full path or you can specify a path\nfor it in curl's `paths` config object.\n\n```javascript\n// example of a fully-pathed plugin under the lib/cssx folder\ndefine(['lib/cssx!myCssFile'], function (cssxDef) {\n\t// do some awesome css stuff here\n});\n```\n\nPlugins can also have configuration options. Global options can be specified\non curl's configuration object. Options can also be supplied to plugins via\nsuffixes. Suffixes are also delineated by the ! symbol. Here's an example of\na plugin using options:\n\n```javascript\n// don't try to repair IE6-8 opacity issues in my css file\ndefine(['css!myCssFile!ignore:opacity'], function (cssxDef) {\n\t// do some awesome css stuff here\n});\n```\n\n----------------------------------------\n\nHow do I use curl.js?\n=====================\n\n1. Learn about AMD-formatted javascript modules if you don't already know how.\n2. Clone or download curl to your local machine or server.\n3. Figure out the baseUrl and paths configuration that makes sense for your\n   project.\n4. Check out the \"API at a glance\" section above to figure out which loading\n   methodology you want to use.\n5. Study the \"Very Simple Example\" and some of the test files.\n6. Try it on your own files.\n\n----------------------------------------\n\nToo Many Modules!\n=================\n\nI have dozens (or hundreds) of modules. Even with parallel loading, the\nperformance sucks! What can I do about that?\n\nTrue! No parallel loader can lessen the latency required to create an HTTP\nconnection. If you have dozens or hundreds of files to download, it's going to\ntake time to initiate each of the connections.\n\nHowever, there are tools to that are designed to fix this problem! There are\nbuilders and compilers. dojo users are probably already familiar with dojo's\nbuild tool and optimizer. RequireJS comes with a build tool and Google's\nClosure compiler.\n\nThe build tool is used to concatenate several modules (and/or resources)\ninto just a few files. It does this by following the dependency chain\nspecified in the define() and require() calls. You can specify which top-level\nmodules or resources are in each file and the build tool finds the rest.\n\nAfter the build tool creates the concatenated files, the files can be passed\ninto a compiler (also called a shrinker or compressor).\n\ncurl.js is compatible with RequireJS's build tool, r.js, but there's\nalso [cram](https://github.com/cujojs/cram).\nCram is the cujoJS resource assembler.\n\n----------------------------------------\n\nPackage Support\n========================\n\ncujoJS supports packages.  Packages are defined by the `packages`\nconfiguration parameter:\n\n```javascript\ncurl = {\n\tbaseUrl: 'path/to/js',\n\tpackages: {\n\t\t'my-package': {\n\t\t\tlocation: 'path/to/my-package',\n\t\t\tmain: 'main/main-module-file',\n\t\t\tconfig: { /* package-specific configuration options */ }\n\t\t}\n\t}\n};\n```\n\n```javascript\ncurl = {\n\tbaseUrl: 'path/to/js',\n\tpackages: [\n\t\t{\n\t\t\tname: 'my-package',\n\t\t\tlocation: 'path/to/my-package',\n\t\t\tmain: 'main/main-module-file',\n\t\t\tconfig: { /* package-specific configuration options */ }\n\t\t}\n\t]\n};\n```\n\nThe path property describes where to find the package in relation to the\nbaseUrl parameter.  The main and lib properties describe where to find modules\ninside the package.  The main property gives the relative path to the package's\nmain module.\n\nIn the example above, the main module of the package can be obtained as follows:\n\n```javascript\ncurl(['my-package'], callback);\n```\n\nand will be fetched from the following path:\n\n\tpath/to/js/path/to/my-package/main/main-module-file.js\n\nSome other file in the package would be obtained as follows:\n\n```javascript\ncurl(['my-package/other-module'], callback);\n```\n\nand will be fetched from the following path:\n\n\tpath/to/js/path/to/my-package/other-module.js\n\n----------------------------------------\n\nWhat is cujoJS?\n=====================\n\ncujoJS is the JavaScript Architectural Toolkit.  It employs MVC, IOC, AMD\nand lots of other TLAs. :)  Our goal is to provide architectural tools and\nguidance.  Find out more at [cujoJS.com](http://cujojs.com).\n\nKudos\n=================\n\nMany thanks to Bryan Forbes ([@bryanforbes](http://www.twitter.com/bryanforbes))\nfor helping to clean up my code and for making curl's domReady much more robust\nand help with dojo compatibility.\nMore about Bryan: <http://www.reigndropsfall.net/>\n\nKudos also to James Burke ([@jrburke](http://www.twitter.com/jrburke)) who\ninstigated the AMD standard and paved the way to create AMD-style loaders.\nMore about James: <http://tagneto.blogspot.com/>\n\nShout out to Kris Zyp ([@kriszyp](http://www.twitter.com/kriszyp)) for\nexcellent ideas and feedback and to Kyle Simpson\n([@getify](http://www.twitter.com/getify)) who is inarguably the godfather of\njavascript loading.\n",
  "readmeFilename": "README.md",
  "_id": "curl@0.8.9",
  "dist": {
    "shasum": "2883c6498a6c1a27a4d94194a22c4b23ba7c7b91"
  },
  "_resolved": "git://github.com/cujojs/curl#261841045bc488c438d34347b588adfc1855faf1",
  "_from": "curl@git://github.com/cujojs/curl"
}
